/*
 *
 * =============================================================
 *
 *       Filename:  套娃程序的设计文档
 *
 *        Version:  1.0
 *        Created:  2010-5-30 22:59:26
 *       Revision:  赵力
 *       Compiler:  MS_VC2005
 *
 *
 * =============================================================
 */

1套娃的结构设计
  对于套娃程序我设计的一个“class cMatrMap”类来抽象相关问题。
首先，这个类具有从给定文件读入数据并储存加工成相关
结构体。


2cMatrMap 数据成员 
	cMatrMap 结构存放了足够详细的路径信息 
int rowSize ;                        /* 东西向道路数 */
int colSize ;                        /* 南北向道路数 */
vector<sNode> line ;                 存放每一个节点的线性表
				     按节点的二位地址顺序存放
				     节点由sNode结构抽象。
int maxGold ;                        /* 最大路径的套娃总重量 */
vector<int> max ;                    最大路径的顺序节点在line中的下标。

3襄套类的说明：
	在cMatrMap中我顶一个两个私有数据结构，之所以定义成私有
结构是因为考虑到封装。
对于每个路口我抽象成节点。我用<struct sNode>结构来存放每一个节点
的有关信息。 
int row ;                       /* 节点所在的行，以0为起始 */
int col ;                       /* 节点所在的列，以0为起始 */
int value ;                     /* 节点的套娃的重量 */
int index ;                     /* line中对应路口的下标 */
vector<vector<sNode>::iterator> link ; link相当于图中的临界表。
				由于对于一个节点来说只能取比他套娃重量大的
				相邻节点。所以，在link 中只保存比该节点大的
				相邻节点，保存节点的顺序是从12点钟方向顺时针 

struct sListNode  结构用来优化查找使得查找速度指数级减少
int index ;                      /* 节点在line中的下标 */
int gold ;                       /* 以该节点开始的最大路径的套娃总重量 */
vector<int> path ;               /* 最大路径各路口顺序在line中的下标 */

        
4查找路径
	可以知道当进入一个节点A后可以到下一个比他大的（或0）的相邻节点B。			
而在到下一个节点B又可以向上面那样倒到他的下一个节点C，对于每一个节点来说，
寻找道路的模式是一样的。所以很自然的将“递归”思想运用的程序的设计当中
函数FindCore 和 FindCoreZero就是处理节点为非零和零时的查找函数。
对于FindCore他将传入的访问节点保存到Road（当前路径），递归访问该节点的link域，
当该节点个所以link域都访问完时。他会比较cMatrMap中的最大路径重量和road中的最大路径重量
如果Road中的最大路径重量大于已记录的最大路径，则会更新路径。
可想象在一个路口矩阵中至少一个节点大于他的所以节点（非全零时),这就保证了递归调用的有限性。
因为搜索会经过每一个可能的路径，所以正确性可以得到保证。

5优化
	由于原始递归算法采用穷举法，经过大量的测试可以看到几乎每一个点都被多次访问。
因为从一个节点开始的最大路径必是唯一。所以我用了sListNode结构来存放以某个节点为起始节点
的最大路径。所以程序只要在首次递归完此节点后，就会的到一次节点开始的最大路径。下次在要访问
时只要查表就可个到最大路径。是的程序效率大大提高。
注：以上优化只针对非零节点，当零节点很多时，效率就会接近没有优化，对于成区域的零节点
我已找到一种方法来优化，但还没有实现。

接口设计：
cMatrMap类 的公共接口只有3个他很好的
cMatrMap  构造接口
InitcMatrMap() ;                        /* 初始化cMatrMap */
FindMaxGold() ;                        /* 寻找最大路径  */
ShowMaxPath() ;

5个私有接口用作类中处理数据  
GetLineIndex(int r, int c) const        /* 二维矩阵下标转换成对应的一维下标 */
 GetNeighbor(vector<sNode>& line) ;     /* 得到比自己套娃重的邻居 */
GT（） :                         在line中查找给定节点
FindCroc()
FindCrocZero()

总结：cMatrMap类较好的抽象了问题和数据，隐藏了具体实现，具有一定的结构性，可靠性。
效率方面有一定的可用性。但还可提高。

后记：通过这次参加比赛我提高了自己抽象能力和编程能力，加强了团队意识，结交个很多朋友。
	认识了自己的不足。虽有一些遗憾但是我还是尽量了。希望自己越远越强。祝愿中兴捧月杯。越办越好。
 
